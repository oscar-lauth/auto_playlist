from fastapi import HTTPException
import requests
import time
import json
from schemas.user import User

# 
spotify_base_url = "https://api.spotify.com/v1"

# creates new User with passed tokens and profile data from Spotify API
def init_user(access_token:str,refresh_token:str,expires_in:int) -> User:

    expire_time = int(time.time()) + expires_in

    url = spotify_base_url + "/me"
    headers = {"Authorization":f"Bearer {access_token}","Content-Type":"application/json"}
    response = requests.get(url,headers=headers)
    res_dict = response.json()

    if("error" in res_dict):
        return res_dict

     # create User
    user = User(u_id=res_dict["id"],display_name=res_dict["display_name"],access_token_=access_token,refresh_token=refresh_token,expires=expire_time)
    return user

# return refreshed access token from Spotify API
# def req_refreshed_access_token()->dict:

#     # settings from env
#     settings:config.Settings = config.get_settings()

#     auth_params = {
#         "grant_type":"refresh_token",
#         "refresh_token":user.refresh_token,
#         "client_id":settings.client_id,
#     }
#     enc_client_tokens = base64.b64encode((settings.client_id+":"+settings.client_secret).encode("utf-8"))
#     headers = {"Authorization": "Basic "+ enc_client_tokens.decode("ascii"),
#     "Content-Type":"application/x-www-form-urlencoded"}
#     response = requests.post("https://accounts.spotify.com/api/token",data=auth_params,headers=headers)
    
#     return response.json()


# create an empty playlist for User
def create_playlist(user:User,name:str,is_public:bool,description:str="Playlist auto-generated by Oscar Lauth") -> dict:

    # forming POST request
    url = spotify_base_url + f"/users/{user.u_id}/playlists"
    params = {"name":name,"description":description,"public":is_public}
    headers = {"Authorization":f"Bearer {user.access_token}","Content-Type":"application/json"}
    response = requests.post(url,data=json.dumps(params),headers=headers)

    res_dict = response.json()
    return res_dict

# add songs to User's playlist from Spotify song URI's
def add_songs_to_playlist(user:User,p_id:str,song_uris:list[str]) -> dict:

    # forming POST request
    url = spotify_base_url + f"/playlists/{p_id}/tracks"
    params = {"uris":song_uris}
    headers = {"Authorization":f"Bearer {user.access_token}","Content-Type":"application/json"}
    response = requests.post(url,data=json.dumps(params),headers=headers)

    res_dict = response.json()
    return res_dict

# get recommendations from build_seed
def get_recommendations(user:User,attributes:dict,limit:int=20) -> dict:

    # forming GET request
    url = spotify_base_url + "/recommendations"
    params = build_seed(user,[3,2,0])
    params.update({"limit":limit})
    params.update(attributes)
    print("params",params)
    headers = {"Authorization":f"Bearer {user.access_token}","Content-Type":"application/json"}
    response = requests.get(url,params=params,headers=headers)
    print(url)
    print(params)
    print(headers)

    res_dict = response.json()
    print("In get_rec,",res_dict)
    if "error" in res_dict:
        return {"Error":"get_recommendations error"}
    return res_dict

# get top tracks
def get_top_tracks_raw(user:User,limit:int=20,offset:int=0,time_range:str="medium_term") -> dict:
    
    # forming GET request
    url = spotify_base_url + f"/me/top/tracks"
    params = {"limit":limit,"offset":offset,"time_range":time_range}
    headers = {"Authorization":f"Bearer {user.access_token}","Content-Type":"application/json"}
    response = requests.get(url,params=params,headers=headers)

    res_dict = response.json()
    return res_dict

# get top artists
def get_top_artists_raw(user:User,limit:int=20,offset:int=0,time_range:str="medium_term") -> dict:

    # forming GET request
    url = spotify_base_url + f"/me/top/artists"
    params = {"limit":limit,"offset":offset,"time_range":time_range}
    headers = {"Authorization":f"Bearer {user.access_token}","Content-Type":"application/json"}
    response = requests.get(url,params=params,headers=headers)

    res_dict = response.json()
    return res_dict


# get list of available genres that can be used as seeds
def get_available_genre_seeds(user:User) -> list[str]:

    # forming GET request
    url = spotify_base_url + f"/recommendations/available-genre-seeds"
    headers = {"Authorization":f"Bearer {user.access_token}","Content-Type":"application/json"}
    response = requests.get(url,headers=headers)

    res_dict = response.json()
    return res_dict["genres"]


# parsing track ID's from raw top tracks
def get_seed_tracks(top_tracks_raw:dict) -> list[str]:
    track_ids:list[str]=[]
    top_tracks = top_tracks_raw["items"]
    for track in top_tracks:
        track_ids.append(track["id"])
    return track_ids


# tracks don't have genres, only artists so this function uses raw top artists to get both artists and genre 
def get_seed_artists_and_genres(user:User,top_artists_raw:dict) -> dict:

    artist_ids:list[str]=[]
    genres:list[str]=[]
    available_genres = get_available_genre_seeds(user)
    top_artists = top_artists_raw["items"]

    for artist in top_artists:
        artist_ids.append(artist["id"])
        if(artist["genres"] in available_genres):
            genres.append(artist["genres"])

    return {"artist_ids":artist_ids,"genres":genres}

# build seed from seed tracks,artists,genres : use num_values to determine number of each seed type
def build_seed(user:User,num_values:list[int]) -> dict:
 
    if(len(num_values)!=3 or sum(num_values)>5):
        return ["Error, invalid parameters"]

    (n_tracks,n_artists,n_genres) = num_values

    seed_tracks = get_seed_tracks(get_top_tracks_raw(user))[:n_tracks]
    seed_artists_genres_dict = get_seed_artists_and_genres(user,get_top_artists_raw(user))
    seed_artists = seed_artists_genres_dict["artist_ids"][:n_artists]
    seed_genres = seed_artists_genres_dict["genres"][:n_genres]

    return {"seed_tracks":seed_tracks,"seed_artists":seed_artists,"seed_genres":seed_genres}

# parse song uri's from recommendations : add {size} number of uri's to playlist
def generate_playlist(user:User,p_id:str,raw_attributes:dict,size:int=20) -> dict:

    song_uris:list[str]=[]
    attributes:dict = parse_attributes(raw_attributes)
    print("In gen_playlist:")
    print("attributes:",attributes)
    
    raw_recs:dict=get_recommendations(user,attributes,size)
    print("raw_recs",raw_recs)
    if "Error" in raw_recs:
        raise HTTPException(status_code=502,detail="get_recommendations error")
    for track in raw_recs["tracks"]:
        song_uris.append(track["uri"])
        
    return add_songs_to_playlist(user,p_id,song_uris)

# parse and reformat raw track attributes from frontend
def parse_attributes(raw_attributes:dict) -> dict:
    attributes:dict = {}
    for k,v in raw_attributes.items():
        if(is_number(v)):
            if k == "popularity":
                attributes["target_"+k] = int(v)
            else:
                attributes["target_"+k] = float(v)
            # attributes["max_"+k] = min(num+.5,1)
            # attributes["target_"+k] = num
            # attributes["min_"+k] = max(num-.5,0)
        else:
            attributes[k]=v
    return attributes

def is_number(num:str) -> bool:
    try:
        float(num)
        return True
    except ValueError:
        return False




